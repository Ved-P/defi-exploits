// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Auction {

    mapping(address=>uint256) bids;

    address public max_address;
    uint256 public max_bid;

    bool public bidding;

    function bid() public {
        require(!bidding, "Please wait for the current round to end");

        bidding = true;
        (bool sent, ) = msg.sender.call{value: 0}(
            abi.encodeWithSignature("onBidding(uint256,uint256)", max_bid, bids[msg.sender])
        );
        require(sent, "Calling to onBidding failed");
        bidding = false;
    }

    receive() external payable {
        bids[msg.sender] += msg.value;
        if (bids[msg.sender] > max_bid) {
            max_bid = bids[msg.sender];
            max_address = msg.sender;
        }
    }

    function buyer() public returns (address) {
        return max_address;
    }
}

contract Bidder {

    function onBidding(uint256 max_bid, uint256 curr_bid) external {
        uint256 rem_bid = max_bid - curr_bid + 1 ether;
        payable(msg.sender).call{value: rem_bid}("");
    }

}