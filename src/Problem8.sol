// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./ReentrancyGuard.sol";
import "./Address.sol";

contract FlashLoanPool is ReentrancyGuard {
    using Address for address;

    error NotEnoughTokenBalance();
    error FlashLoanNotPaidBack();

    function flashLoan(uint256 amount) external nonReentrant {
        uint256 balanceBefore = address(this).balance;

        if (amount > balanceBefore) {
            revert NotEnoughTokenBalance();
        }

        require(msg.sender != tx.origin, "Caller needs to be a contract");

        payable(msg.sender).transfer(amount);

        msg.sender.functionCall(abi.encodeWithSignature("receiveFlashLoan(uint256)", amount));

        if (address(this).balance < balanceBefore) {
            revert FlashLoanNotPaidBack();
        }
    }

    fallback() external payable {}
}

contract RewardPool is ReentrancyGuard {

    mapping(address=>uint256) balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function claim() public {
        require(balances[msg.sender] > 0, "No balance found");
        uint256 bal = balances[msg.sender];
        uint256 bonus = bal / 1000;
        balances[msg.sender] = 0;
        payable(msg.sender).call{value: bal+bonus}("");
    }

}