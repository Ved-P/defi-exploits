// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./ReentrancyGuard.sol";
import "./Address.sol";

contract FlashLoanPool is ReentrancyGuard {
    using Address for address;

    uint256 public profits;
    address public deployer;

    error NotEnoughTokenBalance();
    error FlashLoanNotPaidBack();

    constructor() { init(msg.sender); profits = 0; }
    function init(address _deployer) public {
        deployer = _deployer;
    }

    function flashLoan(uint256 amount) external nonReentrant {
        uint256 balanceBefore = address(this).balance;

        if (amount > balanceBefore) {
            revert NotEnoughTokenBalance();
        }

        require(msg.sender != tx.origin, "Caller needs to be a contract");

        payable(msg.sender).transfer(amount);

        msg.sender.functionCall(abi.encodeWithSignature("receiveFlashLoan(uint256)", amount));

        if (address(this).balance < balanceBefore + 1 ether) {
            revert FlashLoanNotPaidBack();
        }
        profits += address(this).balance - balanceBefore;
    }

    function collectProfits() external nonReentrant {
        payable(address(deployer)).transfer(profits);
        profits = 0;
    }

    fallback() external payable {}
}

contract Helper {
    FlashLoanPool flashloan;

    constructor(FlashLoanPool _flashloan) {
        flashloan = _flashloan;
    }

    function loan() public {
        flashloan.flashLoan(1);
    }

    function receiveFlashLoan(uint256 amount) public {
        require(address(flashloan) == msg.sender, "Someone other than the flashloan pool is calling");
        payable(address(flashloan)).transfer(amount + 1 ether);
    }

    fallback() external payable {}
}