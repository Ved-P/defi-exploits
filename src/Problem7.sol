// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

contract Locker {
    mapping(address=>uint256) public balances;
    mapping(address=>uint256) public starts;
    mapping(address=>uint256) public durations;
    mapping(address=>uint256) public ends;

    function deposit(uint256 d) public payable {
        require(balances[msg.sender] == 0, "You can only deposit once before you withdraw");
        balances[msg.sender] = msg.value;
        starts[msg.sender] = block.timestamp;
        durations[msg.sender] = d;
        ends[msg.sender] = starts[msg.sender] + d;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "No balance to withdraw");
        require(block.timestamp > ends[msg.sender], "Funds not available yet");

        uint256 base_bal = balances[msg.sender];
        uint256 bonus = 0;
        // restrict an upper bound of bonus
        if (durations[msg.sender] > 1000) bonus = 10 ether;
        else bonus = durations[msg.sender] * 0.00001 ether;
        uint256 bal = base_bal + bonus;
        balances[msg.sender] = 0;

        (bool r, ) = msg.sender.call{value: bal}("");
        require(r, "Failed to release funds");
    }

    function balance() public view returns (uint256) {
        return balances[msg.sender];
    }

    function start() public view returns (uint256) {
        return starts[msg.sender];
    }

    function end() public view returns (uint256) {
        return ends[msg.sender];
    }

    function duration() public view returns (uint256) {
        return durations[msg.sender];
    }
}